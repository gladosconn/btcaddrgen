#include "ecdsa_key.h"

#include <cassert>

#include "secp256k1.h"

#include "ecdsa_key_man.h"
#include "randkey.h"

namespace ecdsa {

static int ec_privkey_export_der(const secp256k1_context *ctx,
                                 unsigned char *privkey, size_t *privkeylen,
                                 const unsigned char *key32, int compressed) {
  secp256k1_pubkey pubkey;
  size_t pubkeylen = 0;
  if (!secp256k1_ec_pubkey_create(ctx, &pubkey, key32)) {
    *privkeylen = 0;
    return 0;
  }
  if (compressed) {
    static const unsigned char begin[] = {0x30, 0x81, 0xD3, 0x02,
                                          0x01, 0x01, 0x04, 0x20};
    static const unsigned char middle[] = {
        0xA0, 0x81, 0x85, 0x30, 0x81, 0x82, 0x02, 0x01, 0x01, 0x30, 0x2C, 0x06,
        0x07, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x01, 0x01, 0x02, 0x21, 0x00, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFC, 0x2F, 0x30, 0x06, 0x04, 0x01, 0x00,
        0x04, 0x01, 0x07, 0x04, 0x21, 0x02, 0x79, 0xBE, 0x66, 0x7E, 0xF9, 0xDC,
        0xBB, 0xAC, 0x55, 0xA0, 0x62, 0x95, 0xCE, 0x87, 0x0B, 0x07, 0x02, 0x9B,
        0xFC, 0xDB, 0x2D, 0xCE, 0x28, 0xD9, 0x59, 0xF2, 0x81, 0x5B, 0x16, 0xF8,
        0x17, 0x98, 0x02, 0x21, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xBA, 0xAE, 0xDC,
        0xE6, 0xAF, 0x48, 0xA0, 0x3B, 0xBF, 0xD2, 0x5E, 0x8C, 0xD0, 0x36, 0x41,
        0x41, 0x02, 0x01, 0x01, 0xA1, 0x24, 0x03, 0x22, 0x00};
    unsigned char *ptr = privkey;
    memcpy(ptr, begin, sizeof(begin));
    ptr += sizeof(begin);
    memcpy(ptr, key32, 32);
    ptr += 32;
    memcpy(ptr, middle, sizeof(middle));
    ptr += sizeof(middle);
    pubkeylen = 33;
    secp256k1_ec_pubkey_serialize(ctx, ptr, &pubkeylen, &pubkey,
                                  SECP256K1_EC_COMPRESSED);
    ptr += pubkeylen;
    *privkeylen = ptr - privkey;
  } else {
    static const unsigned char begin[] = {0x30, 0x82, 0x01, 0x13, 0x02,
                                          0x01, 0x01, 0x04, 0x20};
    static const unsigned char middle[] = {
        0xA0, 0x81, 0xA5, 0x30, 0x81, 0xA2, 0x02, 0x01, 0x01, 0x30, 0x2C, 0x06,
        0x07, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x01, 0x01, 0x02, 0x21, 0x00, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFC, 0x2F, 0x30, 0x06, 0x04, 0x01, 0x00,
        0x04, 0x01, 0x07, 0x04, 0x41, 0x04, 0x79, 0xBE, 0x66, 0x7E, 0xF9, 0xDC,
        0xBB, 0xAC, 0x55, 0xA0, 0x62, 0x95, 0xCE, 0x87, 0x0B, 0x07, 0x02, 0x9B,
        0xFC, 0xDB, 0x2D, 0xCE, 0x28, 0xD9, 0x59, 0xF2, 0x81, 0x5B, 0x16, 0xF8,
        0x17, 0x98, 0x48, 0x3A, 0xDA, 0x77, 0x26, 0xA3, 0xC4, 0x65, 0x5D, 0xA4,
        0xFB, 0xFC, 0x0E, 0x11, 0x08, 0xA8, 0xFD, 0x17, 0xB4, 0x48, 0xA6, 0x85,
        0x54, 0x19, 0x9C, 0x47, 0xD0, 0x8F, 0xFB, 0x10, 0xD4, 0xB8, 0x02, 0x21,
        0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xBA, 0xAE, 0xDC, 0xE6, 0xAF, 0x48, 0xA0,
        0x3B, 0xBF, 0xD2, 0x5E, 0x8C, 0xD0, 0x36, 0x41, 0x41, 0x02, 0x01, 0x01,
        0xA1, 0x44, 0x03, 0x42, 0x00};
    unsigned char *ptr = privkey;
    memcpy(ptr, begin, sizeof(begin));
    ptr += sizeof(begin);
    memcpy(ptr, key32, 32);
    ptr += 32;
    memcpy(ptr, middle, sizeof(middle));
    ptr += sizeof(middle);
    pubkeylen = 65;
    secp256k1_ec_pubkey_serialize(ctx, ptr, &pubkeylen, &pubkey,
                                  SECP256K1_EC_UNCOMPRESSED);
    ptr += pubkeylen;
    *privkeylen = ptr - privkey;
  }
  return 1;
}

Key::Key(KeyManager &key_man) : key_man_(key_man) {
  key_.resize(32);
  do {
    rnd::GetStrongRandBytes(key_.data(), key_.size());
  } while (!VerifyKey(key_));
}

KeyData Key::get_key() const { return key_; }

KeyData Key::CalculatePublicKey(bool compressed) const {
  secp256k1_pubkey pubkey;
  size_t clen = PUBLIC_KEY_SIZE;
  KeyData result;
  result.resize(clen);
  int ret = secp256k1_ec_pubkey_create(key_man_.get_context_sign(), &pubkey,
                                       key_.data());
  assert(ret);
  secp256k1_ec_pubkey_serialize(
      key_man_.get_context_sign(), result.data(), &clen, &pubkey,
      compressed ? SECP256K1_EC_COMPRESSED : SECP256K1_EC_UNCOMPRESSED);
  result.resize(clen);
  return result;
}

bool Key::VerifyKey(const KeyData &key) {
  return secp256k1_ec_seckey_verify(key_man_.get_context_sign(), key.data());
}

} // namespace ecdsa
